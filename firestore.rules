/**
 * @fileoverview Firestore Security Rules for "El Pueblo Duerme" Prototyping Mode
 *
 * Core Philosophy:
 * This ruleset prioritizes a secure authorization model while offering flexible data validation to enable rapid prototyping.
 * It enforces strict ownership and role-based access control where appropriate, but relaxes schema validation to allow for faster iteration.
 *
 * Data Structure:
 * - /games/{gameId}: Stores game instances.
 * - /games/{gameId}/players/{userId}: Stores player data for each game.
 * - /events/{eventId}: Stores game events.
 *
 * Key Security Decisions:
 * - User listing is generally disallowed to protect privacy.
 * - Public read access is granted only for collections explicitly intended for public consumption (e.g., /events).
 * - All write operations are protected by authorization checks.
 *
 * Denormalization for Authorization:
 * - The `Player` entity in `/games/{gameId}/players/{userId}` includes a denormalized `gameId` field.
 *   This enables independent authorization checks at the player level without requiring a `get()` call to the parent `/games/{gameId}` document.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures the /games/{gameId} collection.  Allows game creator to manage game.
     * @path /games/{gameId}
     * @allow (create) User 'creatorId' creates a new game.
     * @allow (get) Any authenticated user can read a game.
     * @allow (list) Any authenticated user can list games.
     * @allow (update) User 'creatorId' updates their game.
     * @allow (delete) User 'creatorId' deletes their game.
     * @deny (create) User attempts to create a game with a mismatched creator ID.
     * @principle Enforces ownership for game creation, updates, and deletes.
     */
    match /games/{gameId} {
      allow get, list: if isSignedIn();
      allow create: if request.auth.uid == request.resource.data.creator;
      allow update, delete: if isSignedIn() && isOwner(resource.data.creator);
    }

    /**
     * @description Secures the /games/{gameId}/players/{userId} collection. Allows user to create their player profile.
     * @path /games/{gameId}/players/{userId}
     * @allow (create) User creates their player profile.
     * @allow (get) Authenticated user can get player data.
     * @allow (list) Authenticated user can list player data (potentially for game view).
     * @allow (update) User can update their player profile.
     * @allow (delete) User can delete their player profile.
     * @deny (create) User attempts to create a player profile with a mismatched userId.
     * @principle Enforces user-ownership for player profiles within a game.
     */
    match /games/{gameId}/players/{userId} {
      allow get, list: if isSignedIn();
      allow create: if request.auth.uid == userId;
      allow update, delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Secures the /events/{eventId} collection.
     * @path /events/{eventId}
     * @allow (get) Any user can read game events.
     * @allow (list) Any user can list game events.
     * @allow (create) Game server can create game event.
     * @allow (update) false
     * @allow (delete) false
     * @principle Public read access with restricted write access.
     */
    match /events/{eventId} {
      allow get, list: if true;
      allow create: if false; // TODO: Add validation and proper auth for the game server once implemented
      allow update, delete: if false;
    }

    // --- Helper Functions ---

    /**
     * @description Checks if the request is authenticated.
     * @return {boolean} True if the request is authenticated, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
  }
}