/**
 * # Firestore Security Rules: El Pueblo Duerme
 *
 * ## Core Philosophy
 * This ruleset enforces a security model based on game participation. All users
 * must be authenticated to interact with the data. Users can freely browse and
 * create new games. Once a game is created, access to detailed game data, such as
 * player roles and game logs, is strictly limited to the users participating in
 * that specific game instance. This ensures that sensitive game information
 * remains private to its players.
 *
 * ## Data Structure
 * The data is organized into three top-level collections for clear separation of
 * concerns:
 * - `games/{gameId}`: Contains the main document for each game, including a list
 *   of participant UIDs (`players`) which is the source of truth for access control.
 * - `players/{playerId}`: Stores data for each player within a game. The document ID
 *   is a composite key `{userId}_{gameId}` for efficient lookups.
 * - `game_logs/{gameLogId}`: Contains immutable log entries for game events.
 *
 * ## Key Security Decisions
 * - **Public Game Discovery:** Signed-in users can list all documents in the `games`
 *   collection to discover and join games that are in a 'waiting' status.
 * - **Participant-Only Access:** Reading documents from the `players` and `game_logs`
 *   collections is only permitted if the requesting user is a member of the
 *   corresponding game's `players` array.
 * - **Creator Privileges:** Only the original creator of a game can delete it, and
 *   only before it has started or after it has finished.
 * - **Immutable Logs:** Game logs are write-once and cannot be modified or deleted
 *   after being created, ensuring an untampered audit trail of game events.
 *
 * ## Denormalization for Authorization
 * To create simpler and more performant rules, this model relies on denormalization.
 * The list of all player UIDs is stored directly on the `games/{gameId}` document in the
 * `players` array. Rules for related collections (`players` and `game_logs`) use a
 * `get()` call to this array to authorize access, avoiding complex and slow queries.
 *
 * ## Structural Segregation
 * Data is segregated into distinct top-level collections (`games`, `players`, `game_logs`).
 * This approach provides a clear and secure boundary for list operations. For example,
 * a user can list public game data without being able to list all private player
 * data from every game in the database.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Checks if the requesting user is the creator of a specific game.
     * Reads the creator field from the game document.
     */
    function isGameCreator(gameId) {
      return get(/databases/$(database)/documents/games/$(gameId)).data.creator == request.auth.uid;
    }

    /**
     * Checks if the requesting user is a participant in a specific game.
     * Reads the players array from the game document. Cost: 1 read.
     */
    function isPlayerInGame(gameId) {
      return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/games/$(gameId)).data.players;
    }

    /**
     * Validates that a user is adding only themselves to a game's player list.
     * This is used to control how users can join a game.
     */
    function isJoiningGame(requestData, resourceData) {
      let oldPlayers = resourceData.players;
      let newPlayers = requestData.players;
      return !(request.auth.uid in oldPlayers)
          && request.auth.uid in newPlayers
          && newPlayers.size() == oldPlayers.size() + 1
          && newPlayers.removeAll(oldPlayers).hasOnly([request.auth.uid]);
    }
    
    /**
     * Ensures critical, immutable fields of a game document are not changed on update.
     */
    function areGameFieldsImmutable(requestData, resourceData) {
      return requestData.id == resourceData.id && requestData.creator == resourceData.creator;
    }

    /**
     * @description Rules for the `games` collection, which stores master game documents.
     * @path /games/{gameId}
     * @allow (get/list) Any authenticated user can browse the list of games.
     * @allow (create) An authenticated user creating a new game for themselves.
     * @allow (update) A user adding themselves to a 'waiting' game's `players` list.
     * @deny (delete) A user trying to delete a game they did not create.
     * @principle Public read for discovery, with ownership and shared access for writes.
     */
    match /games/{gameId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.creator == request.auth.uid && request.auth.uid in request.resource.data.players && request.resource.data.id == gameId;
      allow update: if resource != null && isSignedIn() && (isPlayerInGame(gameId) || (resource.data.status == 'waiting' && isJoiningGame(request.resource.data, resource.data))) && areGameFieldsImmutable(request.resource.data, resource.data);
      allow delete: if resource != null && isGameCreator(gameId) && (resource.data.status == 'waiting' || resource.data.status == 'finished');
    }

    /**
     * @description Rules for player documents, containing role, status, etc.
     * @path /players/{playerId} where playerId is `{userId}_{gameId}`
     * @allow (get) A player in game 'game123' reading another player's data from the same game.
     * @allow (create) A user creating their own player document to join a game.
     * @deny (update) A user trying to update another player's document.
     * @deny (list) A user trying to list all players from a game they are not in.
     * @principle Access is granted based on shared membership in the parent game document.
     */
    match /players/{playerId} {
      // The playerId is a composite key: {userId}_{gameId}
        function getPlayerVars(playerId) {
          let parts = playerId.split('_');
          let userId = parts[0];
          let gameId = parts[1];
          return {
            userId: userId,
            gameId: gameId
          };
        }
        function playerVars(playerId) {
            return getPlayerVars(playerId);
        }

      allow get, list: if isPlayerInGame(playerVars(playerId).gameId);
      allow create: if isOwner(playerVars(playerId).userId) && request.resource.data.userId == playerVars(playerId).userId && request.resource.data.gameId == playerVars(playerId).gameId;
      allow update: if resource != null && isOwner(playerVars(playerId).userId) && request.resource.data.userId == resource.data.userId && request.resource.data.gameId == resource.data.gameId;
      allow delete: if resource != null && isOwner(playerVars(playerId).userId);
    }

    /**
     * @description Rules for game log entries, which are immutable records of game events.
     * @path /game_logs/{gameLogId} where gameLogId is `{gameId}_{timestamp}`
     * @allow (get/list) A player in game 'game123' reading the logs for that game.
     * @allow (create) The creator of game 'game123' writing a new log entry.
     * @deny (update/delete) Any user trying to modify or delete an existing log entry.
     * @deny (create) A regular player (not the creator) trying to write a log entry.
     * @principle Shared read access for game members; restricted writes and immutable data.
     */
    match /game_logs/{gameLogId} {
      // The gameLogId is a composite key: {gameId}_{timestamp}
        function getLogVars(gameLogId) {
          let parts = gameLogId.split('_');
          let gameId = parts[0];
          return {
            gameId: gameId,
          };
        }
        function logVars(gameLogId) {
            return getLogVars(gameLogId);
        }

      allow get, list: if isPlayerInGame(logVars(gameLogId).gameId);
      allow create: if isGameCreator(logVars(gameLogId).gameId) && request.resource.data.gameId == logVars(gameLogId).gameId;
      allow update: if false;
      allow delete: if false;
    }
  }
}