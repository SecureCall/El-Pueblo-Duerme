rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isPlayerInGame(gameId, userId) {
      return exists(/databases/$(database)/documents/games/$(gameId)/players/$(userId));
    }

    function isPlayerAlive(gameId, userId) {
        return get(/databases/$(database)/documents/games/$(gameId)/players/$(userId)).data.isAlive == true;
    }

    function getPlayerRole(gameId, userId) {
        return get(/databases/$(database)/documents/games/$(gameId)/playerData/$(userId)).data.role;
    }

    function isLover(gameId, userId) {
        return get(/databases/$(database)/documents/games/$(gameId)/playerData/$(userId)).data.isLover == true;
    }
    
    function isTwin(gameId, userId) {
        let gameData = get(/databases/$(database)/documents/games/$(gameId)).data;
        return gameData.twins != null && (gameData.twins[0] == userId || gameData.twins[1] == userId);
    }
    
    function isFairy(gameId, userId) {
        let role = getPlayerRole(gameId, userId);
        return role == 'seeker_fairy' || role == 'sleeping_fairy';
    }

    match /publicGames/{gameId} {
      allow read: if request.auth != null;
      allow write: if false; // Only server can write
    }
    
    match /games/{gameId} {
      // Allow reads if the user is a player in that game.
      allow get: if isPlayerInGame(gameId, request.auth.uid);
      // Deny listing all games to prevent data scraping.
      allow list: if false;

      // Writes should ONLY be handled by server-side logic (Cloud Functions).
      allow write: if false;
    }

    match /games/{gameId}/players/{playerId} {
      // Allow players in the game to read public data of other players.
      allow read: if isPlayerInGame(gameId, request.auth.uid);
      // Players cannot create, update, or delete other player documents.
      allow write: if false;
    }

    match /games/{gameId}/playerData/{userId} {
      // A player can only read their own private data.
      allow read: if request.auth.uid == userId;
      // Players cannot write to their own private data.
      allow write: if false;
    }

    // Chat channels
    match /games/{gameId}/publicChat/{messageId} {
      allow read: if isPlayerInGame(gameId, request.auth.uid);
      allow create: if isPlayerInGame(gameId, request.auth.uid) && isPlayerAlive(gameId, request.auth.uid) && request.auth.uid == request.resource.data.senderId;
      allow update, delete: if false;
    }
    
    match /games/{gameId}/ghostChat/{messageId} {
      allow read: if isPlayerInGame(gameId, request.auth.uid);
      allow create: if isPlayerInGame(gameId, request.auth.uid) && !isPlayerAlive(gameId, request.auth.uid) && request.auth.uid == request.resource.data.senderId;
      allow update, delete: if false;
    }

    match /games/{gameId}/wolfChat/{messageId} {
      allow read, create: if isPlayerInGame(gameId, request.auth.uid) && 
                            (getPlayerRole(gameId, request.auth.uid) == 'werewolf' || getPlayerRole(gameId, request.auth.uid) == 'wolf_cub');
      allow update, delete: if false;
    }

    match /games/{gameId}/loversChat/{messageId} {
      allow read, create: if isPlayerInGame(gameId, request.auth.uid) && isLover(gameId, request.auth.uid);
      allow update, delete: if false;
    }

    match /games/{gameId}/twinChat/{messageId} {
      allow read, create: if isPlayerInGame(gameId, request.auth.uid) && isTwin(gameId, request.auth.uid);
      allow update, delete: if false;
    }
    
    match /games/{gameId}/fairyChat/{messageId} {
      allow read, create: if isPlayerInGame(gameId, request.auth.uid) && isFairy(gameId, request.auth.uid);
      allow update, delete: if false;
    }
  }
}
